var documenterSearchIndex = {"docs":
[{"location":"types/#Types-1","page":"Types","title":"Types","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"abstract type AbstractAnimal end\nabstract type AbstractPrimate <: AbstractAnimal end\nabstract type AbstractHuman <: AbstractPrimate end\nstruct Person <: AbstractHuman end","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"The generalised framework for this package leans heavily on Julia's type system.","category":"page"},{"location":"types/#Primitive-Types-1","page":"Types","title":"Primitive Types","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"The more primitive a man is the better he believes himself to be.Erich Maria Remarque on idiots","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"The abstract progression types let users create specialised functions.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"AbstractProgression\nAbstractProgramme","category":"page"},{"location":"types/#Lifting.AbstractProgression","page":"Types","title":"Lifting.AbstractProgression","text":"abstract type AbstractProgression end\nstruct LinearProgression <: AbstractProgression end\nstruct DoubleProgression <: AbstractProgression end\nstruct PeriodProgression <: AbstractProgression end\nstruct BlockProgression <: AbstractProgression end\n\nProgression types. Use these to make specialised functions and add new functionality.\n\n\n\n\n\n","category":"type"},{"location":"types/#Lifting.AbstractProgramme","page":"Types","title":"Lifting.AbstractProgramme","text":"AbstractProgramme\n\nProgramme types.\n\n\n\n\n\n","category":"type"},{"location":"types/#Structures-1","page":"Types","title":"Structures","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"Ideas that require people to reorganize their picture of the world provoke hostility.James Gleick on organising things","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"In order to create programmes we need to create a set scheme. This is done via the SetScheme structure.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"SetScheme","category":"page"},{"location":"types/#Lifting.SetScheme","page":"Types","title":"Lifting.SetScheme","text":"mutable struct SetScheme{\n    T1 <: Union{<:AbstractString, Vector{<:AbstractString}},\n    T2 <: Union{<:Integer, Vector{<:Integer}},\n    T3 <: Union{<:Real, Vector{<:Real}},\n    T4 <: Union{<:Function, Vector{<:Function}},\n    T5 <: Bool,\n}\n    type::T1\n    sets::T2\n    reps::T2\n    intensity::T3\n    rpe::T3\n    addWeight::T3\n    roundMode::T4\n    wght::T3\n    rpeMode::T5\nend\n\nThis structure contains user-created set schemes. Its parameters are as follows:\n\ntype defines the set type,\nsets the number of sets of the corresponding type,\nreps is the number of reps in the set,\nintensity is the set intensity,\nrpe is the set's target RPE,\naddWeight is extra weight on top of the normally calculated weight (useful for chains, bands or microplates),\nwght is the set weight, which is calculated later when pairing progression schemes to exercises,\nrpeMode whether the set scheme is defined via RPE or percentage intensity, if true, the values in intensity will be assumed to be RPE and the percentage intensity will be calculated using RPE and the number of reps in the set, else the values in intensity will be used as provided.\n\nIt uses the following constructor, which takes care of any required computations.\n\nSetScheme(;\n    type::T1 = \"Default\",\n    sets::T2 = 5,\n    reps::T2 = 5,\n    intensity::T3 = 0.75,\n    addWeight::T4 = 0,\n    roundMode::T5 = floor,\n    rpeMode::Bool = false,\n) where {\n    T1 <: Union{<:AbstractString, Vector{<:AbstractString}},\n    T2 <: Union{<:Integer, Vector{<:Integer}},\n    T3 <: Union{<:Real, Vector{<:Real}},\n    T4 <: Union{<:Real, Vector{<:Real}},\n    T5 <: Union{<:Function, Vector{<:Function}},\n}\n\nEvery parameter has defaults, so users have the ability to provide only the ones they want to modify.\n\nIf rpeMode == true, intensity is based on RPE, which lies in the interval x  (0 10. If rpeMode == false, then intensity is relative to training max and therefore lies in the interval x  0 1. The lenghts of all input vectors must be equal.\n\nExample\n\nHere we define a simple set scheme. Since we are not providing any added weight via addWeight, that parameter becomes a zero vector.\n\njulia> SampleScheme = SetScheme(;\n           type = [\"Long Rest\", \"Longer Rest\", \"Longest Rest\", \"Optional Forced Reps\"],\n           sets = [1, 2, 1, 1],\n           reps = [12, 14, 10, 5],\n           intensity = [9.5, 10, 10, 10],\n           roundMode = [floor, floor, ceil, ceil],\n           rpeMode = true,\n       )\nSetScheme{Array{String,1},Array{Int64,1},Array{Float64,1},Array{Function,1},Bool}([\"Long Rest\", \"Longer Rest\", \"Longest Rest\", \"Optional Forced Reps\"], [1, 2, 1, 1], [12, 14, 10, 5], [0.6538806237677003, 0.6275409806672554, 0.7041013906002465, 0.8309098462816784], [9.5, 10.0, 10.0, 10.0], [0.0, 0.0, 0.0, 0.0], Function[floor, floor, ceil, ceil], [0.0, 0.0, 0.0, 0.0], true)\n\n\n\n\n\n","category":"type"},{"location":"types/#","page":"Types","title":"Types","text":"After creating our desired set schemes we use them to create a progression.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"Progression","category":"page"},{"location":"types/#Lifting.Progression","page":"Types","title":"Lifting.Progression","text":"struct Progression{\n    T1 <: AbstractProgression,\n    T2 <: AbstractString,\n    T3 <: Integer,\n    T4 <: Union{<:SetScheme, Vector{<:SetScheme}},\n} <: AbstractProgression\n    type::T1\n    name::T2\n    sessions::T3\n    period::T3\n    setScheme::T4\nend\n\nThis structure holds user-defined progressions. Its parameters are as follows:\n\ntype is the progression type which is a subtype of AbstractProgression,\nname is the progression name,\nsessions is the number of different sessions in a week,\nperiod is the progression period,\nsetScheme is a previously defined set scheme or vector of set schemes, the length must be equal to sessions * period.\n\nThis structure lets users create different types of progressions, from simple day in day out progressions to complex undulating periodisation and block progressions.\n\nProgressions are created with the following constructor function,\n\nfunction Progression(;\n    type::T1,\n    name::T2,\n    sessions::T3 = 1,\n    period::T3 = 1,\n    setScheme::T4,\n) where {\n    T1 <: AbstractProgression,\n    T2 <: AbstractString,\n    T3 <: Integer,\n    T4 <: Union{<:SetScheme, Vector{<:SetScheme}},\n}\n\nExample\n\nAssuming we've run the example in SetScheme we can create a simple progression.\n\njulia> SampleProgression = Progression(;\n           type = LinearProgression(),\n           name = \"Progression Name\",\n           setScheme = SampleScheme,\n       )\nProgression{LinearProgression,String,Int64,SetScheme{Array{String,1},Array{Int64,1},Array{Float64,1},Array{Function,1},Bool}}(LinearProgression(), \"Progression Name\", 1, 1, SetScheme{Array{String,1},Array{Int64,1},Array{Float64,1},Array{Function,1},Bool}([\"Long Rest\", \"Longer Rest\", \"Longest Rest\", \"Optional Forced Reps\"], [1, 2, 1, 1], [12, 14, 10, 5], [0.6538806237677003, 0.6275409806672554, 0.7041013906002465, 0.8309098462816784], [9.5, 10.0, 10.0, 10.0], [0.0, 0.0, 0.0, 0.0], Function[floor, floor, ceil, ceil], [0.0, 0.0, 0.0, 0.0], true))\n\n\n\n\n\n","category":"type"},{"location":"types/#","page":"Types","title":"Types","text":"We also need to create an exercise.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"Exercise","category":"page"},{"location":"types/#Lifting.Exercise","page":"Types","title":"Lifting.Exercise","text":"mutable struct Exercise{\n    T1 <: AbstractString,\n    T2 <: Union{AbstractString, Vector{<:AbstractString}},\n    T3 <: Union{AbstractString, Vector{<:AbstractString}},\n    T4 <: Union{AbstractString, Vector{<:AbstractString}},\n    T5 <: Union{AbstractString, Vector{<:AbstractString}},\n    T6 <: Real,\n    T7 <: Real,\n    T8 <: Function,\n}\n    name::T1\n    equipment::T2\n    modality::T3\n    size::T4\n    muscles::T5\n    trainingMax::T6\n    roundBase::T7\n    roundMode::T8\nend\n\nUser created exercises are encapsulated in this structure. Its parameters are as follows:\n\nname is the exercise name,\nequipment is the equipment required,\nmodality are any modifiers to the exercise (for example blocks),\nsize are the size/resistance of said modifiers (for example 2 inch),\nmuscles are the muscles targeted,\ntrainingMax is the training maximum used to calculate set weights when pairing with a progression,\nroundBase is the base to which set weights are rounded,\nroundMode is the rounding function used.\n\nThis uses the following constructor which provides default values for anything users don't need/want to track,\n\nfunction Exercise(;\n    name::T1,\n    equipment::T2 = \"NA\",\n    modality::T3 = \"Default\",\n    muscles::T4 = \"NA\",\n    trainingMax::T6 = 0,\n    size::T5 = \"NA\",\n    roundBase::T7 = 2.5,\n    roundMode::T8 = floor,\n) where {\n    T1 <: AbstractString,\n    T2 <: Union{AbstractString, Vector{<:AbstractString}},\n    T3 <: Union{AbstractString, Vector{<:AbstractString}},\n    T4 <: Union{AbstractString, Vector{<:AbstractString}},\n    T5 <: Union{AbstractString, Vector{<:AbstractString}},\n    T6 <: Real,\n    T7 <: Real,\n    T8 <: Function,\n}\nend\n\nExamples\n\nSay we want to bench press off a 1 inch block and a semi supinated grip on a swiss bar. We can easily create this exercise\n\njulia> BenchAccessory = Exercise(;\n           name = \"Swiss Bar Bench\",\n           modality = [\"Block\" , \"Semi-Supinated\"],\n           equipment = \"Swiss Bar\",\n           size = \"1 inch\",\n           muscles = [\"Pecs\", \"Triceps\", \"Front Delts\"],\n           trainingMax = 100,\n           roundBase = 2.5,\n           roundMode = floor,\n       )\nExercise{String,String,Array{String,1},String,Array{String,1},Float64,Float64,typeof(floor)}(\"Swiss Bar Bench\", \"Swiss Bar\", [\"Block\", \"Semi-Supinated\"], \"1 inch\", [\"Pecs\", \"Triceps\", \"Front Delts\"], 100.0, 2.5, floor)\n\n\n\n\n\n","category":"type"},{"location":"types/#","page":"Types","title":"Types","text":"Finally, we create a programme using the following structure.","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"Programme","category":"page"},{"location":"types/#Lifting.Programme","page":"Types","title":"Lifting.Programme","text":"struct Programme{\n    T1 <: AbstractProgramme,\n    T2 <: AbstractString,\n    T3 <: Dict{Any, Any},\n    T4 <: Vector{Any},\n}\n    type::T1\n    name::T2\n    exerProg::T3\n    days::T4\nend\n\nUser created programmes are made with this structure. The parameters are as follows:\n\ntype is the exercise type and is a subtype of AbstractProgramme (we recommend users define custom concrete types for their programmes),\nname is the programme name (we recommend the name is the same as the programme type),\nexerProg is a dictionary which pairs exercises and progressions with the key-value pair name => (exercise, progression).\ndays is the programme schedule where each entry in the vector has all the exercises for the day.\n\nEach programme is different so the recommendation is to create a typed makeDays function for the programme type.\n\nExamples\n\nAssuming we are using the previously defined Exercise and Progression, we can create a programme. There are a few ways to do so but this is recommended.\n\n# Define the programme's concrete type. Can be used to extend `makeDays`.\nstruct SampleProgramme <: AbstractProgramme end\n\n# Define a dictionary that will contain an Exercise and its corresponding\n# progression as a tuple or vector.\nexerProg = Dict()\n\n# Push exercises and progressions to dictionary. Using named tuples is\n# recommended because it enables dot syntax as well as regular indexing.\n# Each exercise is paired with its progression.\npush!(\n    exerProg,\n    \"BenchAccessory\" => (exercise = BenchAccessory, progression = SampleProgression),\n)\n\n# Define the a function that creates the schedule. This lets you automatically\n# update training maxes and makes changing the programme easier. Here we also\n# define rest days but you can leave them out if need be. `makeDays` will be\n# called for whatever type is given as its first argument. Different programme\n# types will necessarily have and call different `makeDays` functions.\nfunction makeDays(::SampleProgramme, exerProg)\n\n    # One sub array per day you want to track.\n    week = [[], [], [], [], [], [], []]\n\n    # You can 'unroll' the dictionary contents or push them directly to your\n    # schedule. If using named tuples dot syntax and normal numeric indexing\n    # both work\n    # exerProg[\"BenchAccessory\"].exercise == exerProg[\"BenchAccessory\"][1]\n    BenchAccessory = exerProg[\"BenchAccessory\"].exercise\n    BenchAccessoryProg = exerProg[\"BenchAccessory\"].progression\n\n\n    # Push the exercise and progression to whichever day of the week you want.\n    # If the progression has multiple set schemes, the corresponding scheme can\n    # be accessed by adding the index as the last argument.\n    # push!(week[1], BenchAccessory, BenchAccessoryProg, 2)\n    # Which would fail because there is only one set scheme, but if\n    # BenchAccessoryProg were to have more entries that would take the second.\n    # push! is overloaded so it also automatically calculates the required\n    # weights. You can do this manually but this is easier and more reliable.\n    push!(week[1], BenchAccessory, BenchAccessoryProg)   # Day 1\n    push!(week[2], \"Rest\")  # Day 2\n    push!(week[3], BenchAccessory, BenchAccessoryProg)   # Day 3\n    push!(week[4], \"Rest\")  # Day 4\n    push!(week[5], BenchAccessory, BenchAccessoryProg)   # Day 5\n    push!(week[5], \"Rest\")  # Day 6\n    push!(week[7], \"Rest\")  # Day 7\n\n    return week\nend\n\n# Create weekly schedule.\nweek = makeDays(SampleProgramme(), exerProg)\n\n# Create programme.\nsampleProgramme = Programme(\n                            SampleProgramme(),\n                            \"SampleProgramme\",\n                            exerProg,\n                            week\n                        )\n\nIt's recommended users either import the default dictionary Lifting_Programmes and store their programmes there with key equal to the programme name and type. They can also create their own dictionary for their own creations.\n\n\n\n\n\n","category":"type"},{"location":"functions/#Functions-and-Methods-1","page":"Functions & Methods","title":"Functions and Methods","text":"","category":"section"},{"location":"functions/#","page":"Functions & Methods","title":"Functions & Methods","text":"function getBetter!(me::Person, args...)\n    newArgs = []\n    improvements = []\n    for arg in args\n        improve, arg = action(me, arg)\n        push!(newArgs, arg)\n        push!(improvements, improve)\n    end\n    me += improvements\n    me.goal ? getBetter!(me, newArgs...) : return me, newArgs\nend","category":"page"},{"location":"functions/#Utility-1","page":"Functions & Methods","title":"Utility","text":"","category":"section"},{"location":"functions/#","page":"Functions & Methods","title":"Functions & Methods","text":"No citizen has a right to be an amateur in the matter of physical trainingâ€¦ what a disgrace it is for a man to grow old without ever seeing the beauty and strength of which his body is capable.Socrates on strong men","category":"page"},{"location":"functions/#","page":"Functions & Methods","title":"Functions & Methods","text":"There are various utility functions and methods that enable the programme to work, these can be treated as black boxes.","category":"page"},{"location":"functions/#","page":"Functions & Methods","title":"Functions & Methods","text":"Creating a programme's schedule is done by pushing the exercise and progression to a vector, push! and insert! have been defined to let users do so.","category":"page"},{"location":"functions/#","page":"Functions & Methods","title":"Functions & Methods","text":"push!(\n    A::AbstractArray{T, 1} where {T},\n    exercise::Exercise,\n    progression::Progression,\n    i::Integer = 1,\n)\ninsert!(\n    A::AbstractArray{T, 1} where {T},\n    index::Integer,\n    exercise::Exercise,\n    progression::Progression,\n    i::Integer = 1,\n)","category":"page"},{"location":"functions/#Base.push!","page":"Functions & Methods","title":"Base.push!","text":"push!(\n    A::AbstractArray{T, 1} where {T},\n    exercise::Exercise,\n    progression::Progression,\n    i::Integer = 1,\n)\n\nCalculates set weights using exercise.trainingMax and progression.setScheme, then unrolls the relevant data into a named tuple and pushes it to the end of vector A. See insert! which does the same but at a specified index of A.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Base.insert!","page":"Functions & Methods","title":"Base.insert!","text":"insert!(\n    A::AbstractArray{T, 1} where {T},\n    index::Integer,\n    exercise::Exercise,\n    progression::Progression,\n    i::Integer = 1,\n)\n\nCalculates set weights using exercise.trainingMax and progression.setScheme, then unrolls the relevant data into a named tuple and pushes it to index index of vector A. See push! which does the same but in the last index of A.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Analysis-1","page":"Functions & Methods","title":"Analysis","text":"","category":"section"},{"location":"functions/#","page":"Functions & Methods","title":"Functions & Methods","text":"The shortest path between two truths in the real domain passes through the complex domain.Jacques Hadamard on complex analysis being real analysis' daddy","category":"page"},{"location":"functions/#","page":"Functions & Methods","title":"Functions & Methods","text":"One of the purposes of Lifting.jl is to provide an analytic approach to training as well as automatically and dynamically adjust weights based on performance.","category":"page"},{"location":"functions/#","page":"Functions & Methods","title":"Functions & Methods","text":"The building blocks of these more complex functions are calcIntensity, calcRPE, calcReps. We also have a more primitive function intensityArb to calculate intensity that is used in various programmes I've found.","category":"page"},{"location":"functions/#","page":"Functions & Methods","title":"Functions & Methods","text":"calcIntensity(reps::Integer, rpe::Real)\ncalcRPE(reps::Integer, intensity::Real)\ncalcReps(reps::Integer, intensity::Real)\nintensityArb(var::Integer)","category":"page"},{"location":"functions/#Lifting.calcIntensity-Tuple{Integer,Real}","page":"Functions & Methods","title":"Lifting.calcIntensity","text":"calcIntensity(reps::Integer, rpe::Real)\n\nThis function calculates a set's intensity as a function of reps and RPE. It does a disconcertedly good job of reproducing RPE charts. It is defined as follows:\n\nz = dfrac1a + b (x + 10 - y) + (x - 1) left(dfraccx + dfracdyright)\n\nwhere z equiv intensity, x equiv reps, y equiv RPE, a = 0995 b = 00333c = 00025d = 01.\n\nWe cap rpe to 10 and intensity to 1.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Lifting.calcRPE-Tuple{Integer,Real}","page":"Functions & Methods","title":"Lifting.calcRPE","text":"calcRPE(reps::Integer, intensity::Real)\n\nSolving calcIntensity for rpe yields the following function:\n\nx = dfracsqrtleft(a y z - b y^2 z + 10 b y z + c y z - d z - yright)^2 + 4 c y z (b y z + d z) - a y z + b y^2 z - 10 b y z - c y z + d z + y2 z (b y + d)\n\nwhere the variables are the same as calcIntensity.\n\nWe cap intensity to 1 and the rpe to 10.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Lifting.calcReps-Tuple{Integer,Real}","page":"Functions & Methods","title":"Lifting.calcReps","text":"calcReps(intensity::Real, rpe::Real)\n\nSolving calcIntensity for reps yields the following function:\n\ny = dfracsqrtleft(a x z + b x^2 z + 10 b x z + c x z - c z - xright)^2 + 4 b x z left(d x^2 z - d x zright) + a x z + b x^2 z + 10 b x z + c x z - c z - x2 b x z\n\nwhere the variables are the same as calcIntensity.\n\nWe cap intensity to 1 and rpe to 10.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Lifting.intensityArb-Tuple{Integer}","page":"Functions & Methods","title":"Lifting.intensityArb","text":"intensityArb(var::Integer)\n\nCalculates intensity given an arbitrary variable. I've seen this used as a proxy for reps at a given RPE. I've seen var be anything between the number of reps to the number of reps + 2, 4, 6, 8 depending on a target rpe. This makes for a good rough guide. It is defined as\n\nz = dfrac1a + b x\n\nwhere x equiv var and the constants are the same as calcIntensity.\n\nnote: Note\ncalcIntensity works over a much wider range of RPE and rep combinations.\n\n\n\n\n\n","category":"method"},{"location":"functions/#","page":"Functions & Methods","title":"Functions & Methods","text":"We also need to calculate ratios and rep maxes if we want to update our programme dynamically so there are functions for that too. This is done with calcIntensityRatio, calcRPERatio, calcRepRatio, calcRepMax.","category":"page"},{"location":"functions/#","page":"Functions & Methods","title":"Functions & Methods","text":"calcIntensityRatio(\n    actualReps::Integer,\n    actualRPE::Real,\n    targetReps::Integer,\n    targetRPE::Real,\n)\ncalcRPERatio(\n    actualReps::Integer,\n    actualIntensity::Real,\n    targetReps::Integer,\n    targetIntensity::Real,\n)\ncalcRepRatio(\n    actualIntensity::Real,\n    actualRPE::Real,\n    targetIntensity::Real,\n    targetRPE::Real,\n)\ncalcRepMax(\n    weight::Real,\n    actualReps::Integer,\n    actualRPE::Real,\n    targetReps::Integer,\n    targetRPE::Real,\n)","category":"page"},{"location":"functions/#Lifting.calcIntensityRatio-Tuple{Integer,Real,Integer,Real}","page":"Functions & Methods","title":"Lifting.calcIntensityRatio","text":"calcIntensityRatio(\n    actualReps::Integer,\n    actualRPE::Real,\n    targetReps::Integer,\n    targetRPE::Real,\n)\n\nCalculate the ratio between targetIntensity/actualIntensity.\n\nAll RPE values are capped to 10.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Lifting.calcRPERatio-Tuple{Integer,Real,Integer,Real}","page":"Functions & Methods","title":"Lifting.calcRPERatio","text":"calcRPERatio(\n    actualReps::Integer,\n    actualIntensity::Real,\n    targetReps::Integer,\n    targetIntensity::Real,\n)\n\nCalculate the ratio between targetRPE/actualRPE.\n\nAll intensity values are capped to 1.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Lifting.calcRepRatio-NTuple{4,Real}","page":"Functions & Methods","title":"Lifting.calcRepRatio","text":"calcRepRatio(\n    actualIntensity::Real,\n    actualRPE::Real,\n    targetIntensity::Real,\n    targetRPE::Real,\n)\n\nCalculate the ratio between targetReps/actualReps.\n\nAll intensity values are capped to 1 and all rpe values to 10.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Lifting.calcRepMax-Tuple{Real,Integer,Real,Integer,Real}","page":"Functions & Methods","title":"Lifting.calcRepMax","text":"calcRepMax(\n    weight::Real,\n    actualReps::Integer,\n    actualRPE::Real,\n    targetReps::Integer,\n    targetRPE::Real,\n)\n\nCalculates the rep weight for a target number of reps, targetReps, at a target rpe, targetRPE, given an actual number of reps, actualReps, and an actual rpe, actualRPE and weight. It's just the weight multiplied by the intensity ratio.\n\n\n\n\n\n","category":"method"},{"location":"functions/#","page":"Functions & Methods","title":"Functions & Methods","text":"The last purely mathematical function is calcWeights.","category":"page"},{"location":"functions/#","page":"Functions & Methods","title":"Functions & Methods","text":"calcWeights(exercise::Exercise, setScheme::SetScheme)","category":"page"},{"location":"functions/#Lifting.calcWeights-Tuple{Exercise,SetScheme}","page":"Functions & Methods","title":"Lifting.calcWeights","text":"calcWeights(exercise::Exercise, setScheme::SetScheme)\n\nThis function calculates and updates the weights for each set according to the training max specified in exercise.trainingMax and the intensities of the sets in setScheme.\n\n\n\n\n\n","category":"method"},{"location":"functions/#","page":"Functions & Methods","title":"Functions & Methods","text":"In order to calculate and/or adjust training maxes as well as set the next cycle's weights according to a programme's goals we have makeDays, calcWeights, adjustMaxes!, adjustMaxes, updateMaxes! and updateMaxes. For calculating training maxes from logs we have calcTrainingMaxLogs.","category":"page"},{"location":"functions/#","page":"Functions & Methods","title":"Functions & Methods","text":"makeDays()\nadjustMaxes!(\n    name::AbstractString,\n    dict::Dict{Any, Any},\n    actualReps::Integer;\n    weight = missing,\n)\nadjustMaxes(\n    name::AbstractString,\n    dict::Dict{Any, Any},\n    actualReps::Integer;\n    weight = missing,\n)\nupdateMaxes!(prog::Programme, names, reps; idx = missing)\nupdateMaxes(prog::Programme, names, reps; idx = missing)\ncalcTrainingMaxLogs(prog::Programme, names, reps, weight)","category":"page"},{"location":"functions/#Lifting.makeDays-Tuple{}","page":"Functions & Methods","title":"Lifting.makeDays","text":"makeDays()\n\nGeneric function that can be explicitly typed by the user to create their programme's daily schedule. Typed makeDays functions are used by updateMaxes! to update the training days with the new training maxes calculated by adjustMaxes!. See the example in Programme to see how to define typed makeDays.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Lifting.adjustMaxes!-Tuple{AbstractString,Dict{Any,Any},Integer}","page":"Functions & Methods","title":"Lifting.adjustMaxes!","text":"adjustMaxes!(\n    name::AbstractString,\n    dict::Dict{Any, Any},\n    actualReps::Integer;\n    weight = missing,\n)\n\nAdjusts a programme's training maxes using what is expected by the programme and the actual reps, actualReps, performed at the programme's highest intensity for the exercise contained in dict[name]. However, if weight is provided, updateMaxes! will use that to calculate the new training max instead of whatever the programme prescribes.\n\nnote: Note\nAdjustments made to training max are calculated based on what the programme expects vs actual performance. So if you spectacularly fail a set, the adjustment down will be relatively aggressive. Conversely if you absolutely smash it, the adjustment up will be relatively aggressive. Downward adjustments are more aggressive than upward ones.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Lifting.adjustMaxes-Tuple{AbstractString,Dict{Any,Any},Integer}","page":"Functions & Methods","title":"Lifting.adjustMaxes","text":"adjustMaxes(\n    name::AbstractString,\n    dict::Dict{Any, Any},\n    actualReps::Integer;\n    weight = missing,\n)\n\nDoes the same as adjustMaxes! but without updating the programme's training maxes. It returns a tuple with the new training max and the would-be change to the programme's training max, (trainingMax, change)`.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Lifting.updateMaxes!-Tuple{Programme,Any,Any}","page":"Functions & Methods","title":"Lifting.updateMaxes!","text":"updateMaxes!(prog::Programme, names, reps; idx = missing)\n\nnames are the keys of the exercises you want to update, reps contains the reps performed at the corresponding exercise's maximum intensity set of the cycle, idx is optional in case each entry of reps is a vector and you would like to specifically use an index instead of the last entry.\n\nUpdates the programme's training maxes and adjusts the set weights for the next training cycle. It uses adjustMaxes to update training maxes and makeDays to calculate new set weights according to what is expected by the programme vs actual performance. All this is done on a per exercise basis.\n\nSee updateMaxes for a non-mutating version of this function.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Lifting.updateMaxes-Tuple{Programme,Any,Any}","page":"Functions & Methods","title":"Lifting.updateMaxes","text":"updateMaxes(prog::Programme, names, reps; idx = missing)\n\nThe arguments are the same as updateMaxes!.\n\nCalculates the would-be new training maxes and changes to the old training maxes for the next cycle according to what is expected by the programme vs actual performance but does not update the programme in any way. Returns a tuple (trainingMaxes, change) where each entry in the tuple is an array whose entries correspond 1 to 1 to the exercises in names. The new value for trainingMax is not necessarily going to equal to the old value of trainingMax + change, because change is calculated based on how far off the new value for trainingMax is from the old value of trainingMax, and the result is rounded according to the exercise's roundBase and roundMode.\n\nThis is essentially calls adjustMaxes for all the arguments in names. In order to see what a programme's training days would look like under these new training maxes, the easiest thing to do is to create a deepcopy() of the programme and run updateMaxes! on it.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Lifting.calcTrainingMaxLogs-Tuple{Programme,Any,Any,Any}","page":"Functions & Methods","title":"Lifting.calcTrainingMaxLogs","text":"calcTrainingMaxLogs(prog::Programme, names, reps, weight)\n\nThis function does something similar to updateMaxes but for the whole history of entries instead of a single point in time. This is useful for analysing progress.\n\n\n\n\n\n","category":"method"},{"location":"#Do-You-Even-Lift,-Bro?-1","page":"Home","title":"Do You Even Lift, Bro?","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"if lift == true\n    println(\"Yeaah buddy! Lightweight baby! Oooooooooooh\")\nelse\n    println(\"Weak!\")\n    return\nend","category":"page"},{"location":"#Ain't-nuthin'-but-a-peanut!-1","page":"Home","title":"Ain't nuthin' but a peanut!","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"There is no reason to be alive if you can't do deadlifts!\"  Jon Pall Sigmarsson on the simple joys of life","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This is a tool for creating and analysing lifting programmes. It comes with a few premade dictionaries that users can import and modify to make things easier on them. These defaults as well as the programme I'm currently following are found in /src/assets. More details in Defaults.","category":"page"},{"location":"#Lightweight,-Baby!-1","page":"Home","title":"Lightweight, Baby!","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Just remember, somewhere, a little Chinese girl is warming up with your max.     Jim Conroy on overachievers","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In order to make a programme you need 3 things:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"an exercise,\na progression,\na schedule.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We shall pretend to be Brosef, that annoying guy at the gym whose 'programme' consists of bench pressing every day, staring at girls all seshâ€“-incidentally, said girls definitely squat more than himâ€“-and is a neverending font of unsolicited life, lifting, relationship and medical advice that is verifiably false.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We must first create the b e n c h p r e s s, emissary of the bro'onites.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"BenchPress = Exercise(;\n    name = \"Bench Press\",\n    modality = \"Half Rep\",  # Also accepts vectors. Defaults to \"Default\".\n    equipment = \"Barbell\",  # Also accepts vectors. Defaults to \"NA\".\n    size = \"YUGE\", # Also accepts vectors. Defaults to \"NA\".\n    muscles = [\n                muscles[\"triceps\"],\n                muscles[\"front delts\"]\n              ],        # Also accepts scalars. Defaults to \"NA\".\n    trainingMax = 100,  # Defaults to 0.\n    roundBase = 2.5,    # Round to nearest multiple. Defaults to 2.5.\n    roundMode = floor,  # Rounding function. Defaults to floor.\n)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Of course, Brosef is a 'bodybuilder' and is all about dat TUT 'bout dat TUT (time under tension), so he exclusively works at high reps and low intensities despite completing maybe 25% of the rep on a good day. He also takes at least 5 minutes between sets because he needs to replenish his \"ATT\".","category":"page"},{"location":"#","page":"Home","title":"Home","text":"# The arrays must all be of equal length. Entry indices correspond to each other.\nTUT = SetScheme(;\n    type = [\"Long Rest\", \"Longer Rest\", \"Longest Rest\", \"Optional Forced Reps\"],\n    sets = [1, 2, 1, 1],\n    reps = [12, 14, 10, 5],\n    intensity = [\n                  9.5, # Intensity, can be percentage based (decimal form) or RPE\n                  10,  # based. Percentages are capped at 1, RPE at 10.\n                  10,\n                  10\n                ],  \n    roundMode = [\n                  floor,  # Rounding mode. Defaults to an array of floors of the\n                  floor,  # same length as the others (or a scalar if so are the\n                  ceil,   # others).\n                  ceil\n                ],  \n    rpeMode = true, # If true the progression is RPE based, else it is\n                    # percentage based. Defaults to false.\n)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"However his work ethic is without equal so he will always go to failure and sometimes past it and of course his warmup is like 5 kgs below his top sets. Since Brosef only has passing knowledge of percentages, he follows his gut. Interestingly, this means he uses RPE, who'd have thought?","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Brosef is a straight shooter, so he only uses one set scheme, but there is flexibility to create more complex set schemes and arrays of set schemes (see /assets/LiftingProgressions.jl) do create more complex progressions. However, our boi \"be grindin'\"â€“-evidenced by that one time he tried to sell you questionably-sourced protein powderâ€“-he therefore has a straight forward progression that is still giving him linear gains in the same manner Jeffrey Epstein didn't kill himself. Of course, you've slowly been creeping up on him while being half his size but what do you know, you're reading the documentation for a super niche product instead of benching your ass off.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"TheGrind = Progression(;\n    type = LinearProgression(),\n    name = \"We Be Grindin'\",\n    sessions = 1,     # Number of different sessions in a week.\n    period = 1,       # Number of weeks in the period.\n    setScheme = TUT,  # Set scheme. The number of items here\n                      # must be equal to sessions * period.\n)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Brosef now has everything he needs to create his dream programme... aside from half repping bicep curls, quarter repping the leg press and training calves once a month after which he will be missing for a few days because \"he went too hard and crushed legs four days ago\", but this is enough for our purpose. He trains three days a week because he takes his recovery seriously and likes to party, so he can't no-life it like that jacked dude Brosef can totally out-bench.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"# Define the programme's concrete type. Can be used to extend `makeDays`.\nstruct BrosefDreamProgramme <: AbstractProgramme end\n\n# Define a dictionary that will contain an Exercise and its corresponding\n# progression as a tuple or vector.\nexerProg = Dict()\n\n# Push to the dictionary. Using named tuples is recommended and making the\n# key a string of the variable name makes things easier to follow.\npush!(\n    exerProg,\n    \"BenchPress\" => (exercise = BenchPress, progression = TheGrind),\n)\n\n# Define the training week. Extending this to multiple weeks and different days\n# can be done with arrays of arrays.\nweek = []\n# Push the days to the week.\npush!(week, BenchPress, TheGrind)\npush!(week, \"Rest\")\npush!(week, BenchPress, TheGrind)\npush!(week, \"Rest\")\npush!(week, BenchPress, TheGrind)\n\nProgramme(BrosefDreamProgramme(), \"BrosefDreamProgramme\", exerProg, week)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We need to create some dictionaries and arrays to hold the data as well as the type of the programme. This lets Julia work its multiple dispatch magic. There is also a function makeDays that can be extended to work with concrete subtypes of AbstractProgramme, allowing it to specialise for user defined programmes.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To see a more advanced example that showcases the functionality of the package see /assets/nSunsCAP3_OHP_6Day_LP.jl. An example makeDays function can be found in line 386 of the same file.","category":"page"},{"location":"#FAQ-1","page":"Home","title":"FAQ","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"What makes a weightlifting program successful? Your hard work and dedication.     Greg Everett on lifting","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Is it overkill? Most definitely.\nWhat does it do? Lets you create and analyse lifting programmes.\nWhy not use a spreadsheet? This is more general and powerful than a spreadsheet but admittedly less approachable for less techy people.\nWhy not use an app instead? I use an app, Zero to Hero highly recommended. The premium version is cheap and lets you create and modify progressions, it is very, very good. I've also used TM Training in the past and it is also very good but can be annoyingly buggy. I can recommend them both. This serves a different purpose, it serves a more analytic and design-oriented purpose. The apps are great for logging.","category":"page"},{"location":"#Defaults-1","page":"Home","title":"Defaults","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This is for sex <violent hip thrusts>. This is for snatch <brings barbell to hip crease>.Dmitry Klokov on the snatch ;)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"These are the default dictionaries defined in the programme. They are not explicitly exported so must be explicitly imported or accessed with the dot syntax:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"import Lifting: Lifting_Aux\n\nLifting.Lifting_Exercise_Names","category":"page"},{"location":"#","page":"Home","title":"Home","text":"They dictionaries define the following keys. Explore them to see what they contain, add what you need... or not use them at all!","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> keys(Lifting_Aux)\nBase.KeySet for a Dict{String,Dict{String,String}} with 5 entries. Keys:\n  \"modality\"\n  \"setType\"\n  \"muscles\"\n  \"equipmentSize\"\n  \"equipment\"\n\njulia> keys(Lifting_Exercise_Names)\nBase.KeySet for a Dict{String,Dict{String,String}} with 10 entries. Keys:\n  \"grip\"\n  \"bench\"\n  \"squat\"\n  \"press\"\n  \"isometric\"\n  \"core\"\n  \"pull\"\n  \"row\"\n  \"deadlift\"\n  \"lowBack\"\n\njulia> keys(Lifting_Progressions)\nBase.KeySet for a Dict{String,Progression} with 14 entries. Keys:\n  \"AMRAP_Cali\"\n  \"nSuns_6Day_OHP\"\n  \"AMRAP_Grip\"\n  \"l23_lmh\"\n  \"m23_lmh\"\n  \"h23_lmh\"\n  \"CAP3_Bench_T1\"\n  \"CAP3_Row_T1\"\n  \"CAP3_Squat_T2\"\n  \"CAP3_Deadlift_T1\"\n  \"CAP3_Squat_T1\"\n  \"CAP3_Bench_T2\"\n  \"CAP3_Deadlift_T2\"\n  \"CAP3_Row_T2\"\n\njulia> keys(Lifting_Programmes)\nBase.KeySet for a Dict{String,Programme} with 1 entry. Keys:\n  \"nSunsCAP3_OHP_6Day_LP\"","category":"page"},{"location":"#Adding-to-the-Package-1","page":"Home","title":"Adding to the Package","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Everybody wants to be a bodybuilder, but nobody wants to lift no heavy-ass weights!Ronnie Coleman on heavy metal","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The recommended way for users to add their own creations to the package is to do so in the relevant /src/assets files and push them to their corresponding dictionaries. These can then be imported as normal. Users may also define their own modules that expand Lifting.jl's functionality. These user-made modules can then be imported instead. Alternatively, additions may be made in their local environments, it will simply crowd your workspace.","category":"page"},{"location":"dictionaries/#Defaults-1","page":"Defaults","title":"Defaults","text":"","category":"section"},{"location":"dictionaries/#","page":"Defaults","title":"Defaults","text":"function ishappy(me::Person, circumstance!::Function, happy::Bool=true, args...; kwargs...)\n    circumstance!(me, args...; kwargs...)\n    me.happyIndexChange > 0 ? return happy : return !happy\nend","category":"page"},{"location":"dictionaries/#Dictionaries-1","page":"Defaults","title":"Dictionaries","text":"","category":"section"},{"location":"dictionaries/#","page":"Defaults","title":"Defaults","text":"Dictionary, n. A malevolent literacy device for cramping the growth of a language and making it hard and inelastic.Ambrose Bierce on the evils of dictionaries","category":"page"},{"location":"dictionaries/#","page":"Defaults","title":"Defaults","text":"We've define a set of default dictionaries to make life easier and standardise the extra information users may want to add to their exercises and set schemes. These dictionaries can be expanded by the users using the push!() and insert!() intrinsics. Pull requests adding more entries to the defaul dictionaries are always welcome.","category":"page"},{"location":"dictionaries/#","page":"Defaults","title":"Defaults","text":"note: Note\nNone of these dictionaries are explicitly exported by Lifting.jl. Use them with the Lifting. prefix or import them explicitly.","category":"page"},{"location":"dictionaries/#","page":"Defaults","title":"Defaults","text":"Lifting_Aux\nLifting_Exercise_Names\nLifting_Progressions\nLifting_Programmes","category":"page"},{"location":"dictionaries/#Lifting.Lifting_Aux","page":"Defaults","title":"Lifting.Lifting_Aux","text":"Lifting_Aux::Dict{String, Dict{String, String}}\n\nIs a dictionary of dictionaries containing non-essential information about exercises and progressions. Its default keys are,\n\njulia> keys(Lifting_Aux)\nBase.KeySet for a Dict{String,Dict{String,String}} with 5 entries. Keys:\n  \"modality\"\n  \"setType\"\n  \"muscles\"\n  \"equipmentSize\"\n  \"equipment\"\n\nwhere each entry is a dictionary with its own keys and values.\n\n\n\n\n\n","category":"constant"},{"location":"dictionaries/#Lifting.Lifting_Exercise_Names","page":"Defaults","title":"Lifting.Lifting_Exercise_Names","text":"Lifting_Exercise_Names::Dict{String, Dict{String, String}}\n\nIs a dictionary of dictionaries containing lifting exercises. Its default keys are,\n\njulia> import: Lifting_Exercise_Names\njulia> keys(Lifting_Exercise_Names)\nBase.KeySet for a Dict{String,Dict{String,String}} with 10 entries. Keys:\n  \"grip\"\n  \"bench\"\n  \"squat\"\n  \"press\"\n  \"isometric\"\n  \"core\"\n  \"pull\"\n  \"row\"\n  \"deadlift\"\n  \"lowBack\"\n\nwhere each entry is a dictionary with its own keys and values.\n\n\n\n\n\n","category":"constant"},{"location":"dictionaries/#Lifting.Lifting_Progressions","page":"Defaults","title":"Lifting.Lifting_Progressions","text":"Lifting_Progressions::Dict{String, Progression}\n\nDictionary with preloaded progressions. These are just the progressions I use in my current programme.\n\njulia> import Lifting: Lifting_Progressions\njulia> keys(Lifting_Progressions)\nBase.KeySet for a Dict{String,Progression} with 14 entries. Keys:\n  \"AMRAP_Cali\"\n  \"nSuns_6Day_OHP\"\n  \"AMRAP_Grip\"\n  \"l23_lmh\"\n  \"m23_lmh\"\n  \"h23_lmh\"\n  \"CAP3_Bench_T1\"\n  \"CAP3_Row_T1\"\n  \"CAP3_Squat_T2\"\n  \"CAP3_Deadlift_T1\"\n  \"CAP3_Squat_T1\"\n  \"CAP3_Bench_T2\"\n  \"CAP3_Deadlift_T2\"\n  \"CAP3_Row_T2\"\n\n\n\n\n\n","category":"constant"},{"location":"dictionaries/#Lifting.Lifting_Programmes","page":"Defaults","title":"Lifting.Lifting_Programmes","text":"Lifting_Programmes::Dict{String, Programme}\n\nDictionary with preloaded programmes. These are the programmes I've created and added to the dictionary.\n\njulia> import Lifting: Lifting_Programmes\njulia> keys(Lifting_Programmes)\nBase.KeySet for a Dict{String,Programme} with 1 entry. Keys:\n  \"nSunsCAP3_OHP_6Day_LP\"\n\n\n\n\n\n","category":"constant"},{"location":"io/#Breathe-in,-breath-out-1","page":"IO","title":"Breathe in, breath out","text":"","category":"section"},{"location":"io/#","page":"IO","title":"IO","text":"println(\"t00t t00t.\")\nprintln(\"ðŸ’€ðŸŽºðŸŽµ\")","category":"page"},{"location":"io/#","page":"IO","title":"IO","text":"The package is capable of displaying programmes in the console, writing CSV files and using CSV files for plotting and analysis.","category":"page"},{"location":"io/#Printing-1","page":"IO","title":"Printing","text":"","category":"section"},{"location":"io/#","page":"IO","title":"IO","text":"What gunpowder did for war, the printing press has done for the mind.Wendell Phillips on pressing ink to paper","category":"page"},{"location":"io/#","page":"IO","title":"IO","text":"The default printing does a poor job of displaying the programme so we multiple-dispatched our way into making it look pretty like Robert Oberst.","category":"page"},{"location":"io/#","page":"IO","title":"IO","text":"println(::Programme, ::Any)","category":"page"},{"location":"io/#Base.println-Tuple{Programme,Any}","page":"IO","title":"Base.println","text":"println(programme::Programme, idx = 1:length(programme))\n\nPrints the programme in console in a nicely formatted style. Users can optionally provide an index, be it an integer, unit range, tuple or array. The index corresponds to the day. Function write writes to a csv and has the same indexing functionality.\n\nExamples\n\nprintln(MyProg)             # Prints whole programme.\nprintln(MyProg, 1)          # Prints day 1.\nndays = length(MyProg)      # Length returns the number of days.\nprintln(MyProg, 1:2:ndays)  # Prints every second day starting from the first.\nprintln(MyProg, [1, 5, 20]) # Prints days 1, 5 and 20 (also works with tuples).\n\n\n\n\n\n","category":"method"},{"location":"io/#","page":"IO","title":"IO","text":"May the Programme be with you, always. This lets you do so, implement the programme in your favourite app, put on google sheets, log your progress, and then use that log to analyse your progress with loadLogFile and plotData. Alternatively, be a monster and print everything out, who needs trees anyway?","category":"page"},{"location":"io/#","page":"IO","title":"IO","text":"write(\n    ::AbstractString,\n    ::Programme,\n    ::Any;\n    ::Char,\n    ::Bool,\n)","category":"page"},{"location":"io/#Base.write-Tuple{AbstractString,Programme,Any}","page":"IO","title":"Base.write","text":"write(\n    filename::AbstractString,\n    programme::Programme,\n    idx = 1:length(programme);\n    delim::Char = ',',\n    log::Bool = false,\n)\n\nWrites programme to CSV. It defaults to delimiting the file with commas but you can choose your own. If log == true, generate a log file where users can log their progress. Automatically appends \"Log_\" to the start of the filename. Indexing works the same way as println.\n\nnote: Note\nThe log file will print every exercise in the programme, even those you may not care about. These can be deleted. However if you do so, make sure to change the number in cell [1,1] (top left) to the number of exercises you're keeping track of. This number is used by the programme to know how many columns to read.\n\n\n\n\n\n","category":"method"},{"location":"io/#Analysis-and-Utility-1","page":"IO","title":"Analysis and Utility","text":"","category":"section"},{"location":"io/#","page":"IO","title":"IO","text":"Data is the blood of any organization; coming from everywhere, used everywhere, connecting all the body, transferring messages and when analysed it reflects the whole picture of the body.Khalid Abulmajd on anthropomorphic moral persons","category":"page"},{"location":"io/#","page":"IO","title":"IO","text":"If you've been logging your progress like a good lifter you can load it into Julia for some a n a l y t i c s.","category":"page"},{"location":"io/#","page":"IO","title":"IO","text":"loadLogFile(programme::Programme)","category":"page"},{"location":"io/#Lifting.loadLogFile-Tuple{Programme}","page":"IO","title":"Lifting.loadLogFile","text":"loadLogFile(programme::Programme)\n\nLoads the programme's log file and returns the following values:\n\nkeyArr is array of exercise names which double as the keys for the other outputs,\ndate is a dictionary containing the dates in which each exercise was performed,\nday1 is a dictionary containing the first date on which each exercise was performed,\nÎ”days is a dictionary containing the number of days elapsed from the between day1 and the last registered date,\nreps is a dictionary containing the number of reps performed,\nwght is a dictionary containing the weight used,\nrpe is a dictionary containing the rpe for the set.\n\nThe function drops missing values so every exercise will have all its corresponding pieces of data for a given date. It also doesn't matter if you logged only reps and weight for a session, you just won't have the data point for that session's rpe. The only thing you have to worry about is logging your progress properly. For a nice summary of progress I recommend logging only the top sets for each entry, you can have more of course but you will have to filter out data to make valuable analyses. Regardless, logging all your sessions in a notebook or app is recommended.\n\nIt assumes the filename was not changed from the one generated by write.\n\n\n\n\n\n","category":"method"},{"location":"io/#","page":"IO","title":"IO","text":"Logs usually use dates, but we never want to know our progress as a function date do we? We want it as a function of time. This turns dates into number of days between the earliest date and the rest.","category":"page"},{"location":"io/#","page":"IO","title":"IO","text":"numDays(dates; format = \"dd/mm/yyyy\")","category":"page"},{"location":"io/#Lifting.numDays-Tuple{Any}","page":"IO","title":"Lifting.numDays","text":"numDays(dates; format = \"dd/mm/yyyy\")\n\nTakes an array strings which represent dates in the format provided and calculates the number of days between the first and last entries.\n\n\n\n\n\n","category":"method"},{"location":"io/#","page":"IO","title":"IO","text":"A picture is worth a thousand words, a lifter is worth at least half a human.","category":"page"},{"location":"io/#","page":"IO","title":"IO","text":"plotData(prog::Programme, names, x, y, args...; kwargs...)\nplotData!(figure, prog::Programme, names, x, y, args...; kwargs...)\nscatterData(prog::Programme, names::Vector{Any}, x, y, args...; kwargs...)\nscatterData!(fig, prog::Programme, names::Vector{Any}, x, y, args...; kwargs...)","category":"page"},{"location":"io/#Lifting.plotData-Tuple{Programme,Any,Any,Any,Vararg{Any,N} where N}","page":"IO","title":"Lifting.plotData","text":"plotData(prog::Programme, names::Vector{Any}, x, y, args...; kwargs...)\n\nPlot your hard earned progress with smooth curves and labels the figures appropriately. Skips missing values so your programme won't crash. Creates a new figure for each call, creating an array of figures. For mutating the same figure see plotData!.\n\n\n\n\n\n","category":"method"},{"location":"io/#Lifting.plotData!-Tuple{Any,Programme,Any,Any,Any,Vararg{Any,N} where N}","page":"IO","title":"Lifting.plotData!","text":"plotData!(fig, prog::Programme, names::Vector{Any}, x, y, args...; kwargs...)\n\nSame as plotData but mutates the input figure.\n\n\n\n\n\n","category":"method"},{"location":"io/#Lifting.scatterData-Tuple{Programme,Array{Any,1},Any,Any,Vararg{Any,N} where N}","page":"IO","title":"Lifting.scatterData","text":"scatterData(prog::Programme, names::Vector{Any}, x, y, args...; kwargs...)\n\nMakes a scatter plot of the data. For mutating the same figure see scatterData!.\n\n\n\n\n\n","category":"method"},{"location":"io/#Lifting.scatterData!-Tuple{Any,Programme,Array{Any,1},Any,Any,Vararg{Any,N} where N}","page":"IO","title":"Lifting.scatterData!","text":"scatterData!(fig, prog::Programme, names::Vector{Any}, x, y, args...; kwargs...)\n\nSame as scatterData but mutates the figure.\n\n\n\n\n\n","category":"method"}]
}
